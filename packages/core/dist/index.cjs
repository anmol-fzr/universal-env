"use strict";var R=Object.create;var v=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var O=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,F=Object.prototype.hasOwnProperty;var $=(e,n)=>{for(var a in n)v(e,a,{get:n[a],enumerable:!0})},E=(e,n,a,s)=>{if(n&&typeof n=="object"||typeof n=="function")for(let p of O(n))!F.call(e,p)&&p!==a&&v(e,p,{get:()=>n[p],enumerable:!(s=k(n,p))||s.enumerable});return e};var g=(e,n,a)=>(a=e!=null?R(A(e)):{},E(n||!e||!e.__esModule?v(a,"default",{value:e,enumerable:!0}):a,e)),P=e=>E(v({},"__esModule",{value:!0}),e);var Y={};$(Y,{validateEnv:()=>X});module.exports=P(Y);var j=()=>typeof Bun<"u",B=()=>typeof Deno<"u";async function Z(e,n){if(j()){await Bun.write(e,n);return}if(B()){await Deno.writeTextFile(e,n);return}if(typeof process<"u"&&typeof require<"u"){let{writeFile:a}=await import("fs/promises");await a(e,n,"utf-8");return}throw new Error("Unsupported runtime for file writing")}var te=require("zod");var N=g(require("typescript"),1),T=g(require("typescript"),1),V=e=>({...{nativeEnums:e?.resolveNativeEnums?"resolve":"identifier"},...e}),{factory:m,SyntaxKind:h,ScriptKind:C,ScriptTarget:M,EmitHint:G}=T.default,K=e=>T.default.isIdentifier(e)?m.createTypeReferenceNode(e):e,W=e=>m.createTypeReferenceNode(m.createIdentifier(e)),S=()=>m.createKeywordTypeNode(h.UnknownKeyword);var L=(e,n)=>{let a=T.default.createSourceFile("print.ts","",M.Latest,!1,C.TS);return T.default.createPrinter(n).printNode(G.Unspecified,e,a)};var q=/^[$A-Z_a-z][\w$]*$/,b=e=>q.test(e)?m.createIdentifier(e):m.createStringLiteral(e),H=(e,n)=>{T.default.addSyntheticLeadingComment(e,h.MultiLineCommentTrivia,`* ${n} `,!0)},{factory:r,SyntaxKind:y}=N.default,J=(e,n,a)=>{let s;return e._def.getType&&(s=e._def.getType(N.default,n,a)),s},I=(e,n,a)=>{let s=n??"Identifier",p=V(a),u={nativeEnums:[]};return{node:c(e,s,u,p),store:u}},c=(e,n,a,s)=>{let p=e._def.typeName,u=J(e,n,s);if(u&&p!=="ZodNativeEnum")return K(u);let i=[n,a,s];switch(p){case"ZodString":return r.createKeywordTypeNode(y.StringKeyword);case"ZodNumber":return r.createKeywordTypeNode(y.NumberKeyword);case"ZodBigInt":return r.createKeywordTypeNode(y.BigIntKeyword);case"ZodBoolean":return r.createKeywordTypeNode(y.BooleanKeyword);case"ZodDate":return r.createTypeReferenceNode(r.createIdentifier("Date"));case"ZodUndefined":return r.createKeywordTypeNode(y.UndefinedKeyword);case"ZodNull":return r.createLiteralTypeNode(r.createNull());case"ZodVoid":return r.createUnionTypeNode([r.createKeywordTypeNode(y.VoidKeyword),r.createKeywordTypeNode(y.UndefinedKeyword)]);case"ZodAny":return r.createKeywordTypeNode(y.AnyKeyword);case"ZodUnknown":return S();case"ZodNever":return r.createKeywordTypeNode(y.NeverKeyword);case"ZodLazy":{if(!u)return W(n);break}case"ZodLiteral":{let t,o=e._def.value;switch(typeof o){case"number":{t=r.createNumericLiteral(o);break}case"boolean":{t=o===!0?r.createTrue():r.createFalse();break}default:{t=r.createStringLiteral(o);break}}return r.createLiteralTypeNode(t)}case"ZodObject":{let o=Object.entries(e._def.shape()).map(([d,l])=>{let f=l,w=c(f,...i),{typeName:D}=f._def,x=D==="ZodOptional"||f.isOptional(),_=r.createPropertySignature(void 0,b(d),x?r.createToken(y.QuestionToken):void 0,w);return f.description&&H(_,f.description),_});return r.createTypeLiteralNode(o)}case"ZodArray":{let t=c(e._def.type,...i);return r.createArrayTypeNode(t)}case"ZodEnum":{let t=e._def.values.map(o=>r.createLiteralTypeNode(r.createStringLiteral(o)));return r.createUnionTypeNode(t)}case"ZodUnion":{let o=e._def.options.map(d=>c(d,...i));return r.createUnionTypeNode(o)}case"ZodDiscriminatedUnion":{let o=[...e._def.options.values()].map(d=>c(d,...i));return r.createUnionTypeNode(o)}case"ZodEffects":return c(e._def.schema,...i);case"ZodNativeEnum":{let t=u;if(s.nativeEnums==="union"){if(t)return K(t);let o=Object.values(e._def.values).map(d=>typeof d=="number"?r.createLiteralTypeNode(r.createNumericLiteral(d)):r.createLiteralTypeNode(r.createStringLiteral(d)));return r.createUnionTypeNode(o)}if(!t)return S();if(s.nativeEnums==="resolve"){let o=Object.entries(e._def.values).map(([d,l])=>{let f=typeof l=="number"?r.createNumericLiteral(l):r.createStringLiteral(l);return r.createEnumMember(b(d),f)});if(N.default.isIdentifier(t))a.nativeEnums.push(r.createEnumDeclaration(void 0,t,o));else throw new Error('getType on nativeEnum must return an identifier when nativeEnums is "resolve"')}return K(t)}case"ZodOptional":{let t=c(e._def.innerType,...i);return r.createUnionTypeNode([t,r.createKeywordTypeNode(y.UndefinedKeyword)])}case"ZodNullable":{let t=c(e._def.innerType,...i);return r.createUnionTypeNode([t,r.createLiteralTypeNode(r.createNull())])}case"ZodTuple":{let t=e._def.items.map(o=>c(o,...i));return r.createTupleTypeNode(t)}case"ZodRecord":{let t=c(e._def.valueType,...i);return r.createTypeLiteralNode([r.createIndexSignature(void 0,[r.createParameterDeclaration(void 0,void 0,r.createIdentifier("x"),void 0,r.createKeywordTypeNode(y.StringKeyword))],t)])}case"ZodMap":{let t=c(e._def.valueType,...i),o=c(e._def.keyType,...i);return r.createTypeReferenceNode(r.createIdentifier("Map"),[o,t])}case"ZodSet":{let t=c(e._def.valueType,...i);return r.createTypeReferenceNode(r.createIdentifier("Set"),[t])}case"ZodIntersection":{let t=c(e._def.left,...i),o=c(e._def.right,...i);return r.createIntersectionTypeNode([t,o])}case"ZodPromise":{let t=c(e._def.type,...i);return r.createTypeReferenceNode(r.createIdentifier("Promise"),[t])}case"ZodFunction":{let t=e._def.args._def.items.map((l,f)=>{let w=c(l,...i);return r.createParameterDeclaration(void 0,void 0,r.createIdentifier(`args_${f}`),void 0,w)});t.push(r.createParameterDeclaration(void 0,r.createToken(y.DotDotDotToken),r.createIdentifier(`args_${t.length}`),void 0,r.createArrayTypeNode(S())));let o=c(e._def.returns,...i);return r.createFunctionTypeNode(void 0,t,o)}case"ZodDefault":{let t=c(e._def.innerType,...i),o=[];return t.forEachChild(d=>{[y.UndefinedKeyword].includes(d.kind)||o.push(d)}),t.types=o,t}}return r.createKeywordTypeNode(y.AnyKeyword)};function U(e){let n=I(e);return L(n.node)}var Q="{{content}}";async function X({schema:e,rawEnv:n=process.env,path:a,wrapper:s}){try{await e.parseAsync(n),console.log("Envs Validated Successfully");let p=U(e);if(s){let u=s.replace(Q,p);await Z(a,u)}else await Z(a,p);console.log("Env Types Added Successfully")}catch(p){throw new Error(p)}}0&&(module.exports={validateEnv});
